<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ”ãƒ¨ã‚ã— - ã‚†ã£ãã‚Šèª¿æ•´ç‰ˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

  <!-- PWAè¨­å®š -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#87CEEB">

  <!-- ã‚¢ã‚¤ã‚³ãƒ³ -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ¥</text></svg>">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ¥</text></svg>">

  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background-color: #f0f8ff;
      font-family: "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      cursor: pointer;
    }

    #gameCanvas {
      display: block;
      background-color: #87CEEB;
      width: 100%;
      height: 100%;
    }

    #uiContainer {
      position: absolute;
      top: env(safe-area-inset-top, 20px);
      left: 0;
      width: 100%;
      padding: 10px 20px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 10;
    }

    #statusArea {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 5px;
    }

    #lifeContainer {
      font-size: 28px;
      letter-spacing: 2px;
      filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
      height: 35px;
    }

    #healthBarContainer {
      width: 150px;
      height: 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,0.5);
    }

    #healthBarInner {
      width: 100%;
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.2s, background-color 0.2s;
    }

    /* ã‚¹ã‚³ã‚¢ï¼‹å€ç‡è¡¨ç¤º */
    #scoreArea {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    #scoreDisplay {
      font-size: 32px;
      font-weight: 900;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      font-family: monospace;
    }

    #multiplierDisplay {
      font-size: 16px;
      font-weight: 700;
      color: #ffeb3b;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
      min-height: 18px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    #messageArea {
      position: absolute;
      top: 150px;
      width: 100%;
      text-align: center;
      font-size: 18px;
      line-height: 1.6;
      font-weight: bold;
      color: #fff;
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
      white-space: nowrap;
    }

    #gameOverScreen {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 20;
      min-width: 280px;
    }

    #gameOverScreen h2 {
      margin-top: 0;
      font-size: 2.5em;
      color: #d9534f;
    }

    #finalScore {
      font-size: 1.8em;
      margin: 20px 0;
      color: #333;
      font-weight: bold;
    }

    #restartButton {
      font-size: 1.4em;
      padding: 15px 40px;
      background-color: #5cb85c;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      font-weight: bold;
    }

    #restartButton:active {
      transform: scale(0.95);
    }

    /* ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º */
    #highlights {
      margin-top: 20px;
      text-align: left;
      font-size: 14px;
      color: #555;
    }
    #highlights div {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>

  <canvas id="gameCanvas"></canvas>

  <div id="uiContainer">
    <div id="statusArea">
      <div id="lifeContainer">â¤ï¸â¤ï¸â¤ï¸</div>
      <div id="healthBarContainer">
        <div id="healthBarInner"></div>
      </div>
    </div>
    <div id="scoreArea">
      <div id="scoreDisplay">0</div>
      <div id="multiplierDisplay"></div>
    </div>
  </div>

  <div id="messageArea">
    ãªãã£ã¦æ¨ªç§»å‹•<br>
    ã‚¿ãƒƒãƒã§ãƒ‘ãƒ³ãƒ<br>
    é•·æŠ¼ã—ã§é£Ÿã¹ã‚‹ãƒ»ä»²é–“ã‚²ãƒƒãƒˆ<br>
    <span style="color:#ffeb3b">ãƒ’ãƒ¨ã‚³ã‚’é€²åŒ–ã•ã›ã‚ˆã†ï¼</span>
  </div>

  <div id="gameOverScreen">
    <h2>GAME OVER</h2>
    <div id="finalScore">SCORE: 0</div>
    <div id="highlights">
      <div>ã™ãã™ãè‚²ã£ãŸæ•°: <span id="statSukusuku">0</span></div>
      <div>ä»²é–“ã«ã—ãŸãƒ€ãƒ³ã‚µãƒ¼ã®æ•°: <span id="statPartner">0</span></div>
    </div>
    <button id="restartButton">ã‚‚ã†ä¸€å›ï¼</button>
  </div>

  <script>
  (function() {
    // --- 1. ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const lifeContainer = document.getElementById('lifeContainer');
    const healthBar = document.getElementById('healthBarInner');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const multiplierDisplay = document.getElementById('multiplierDisplay');
    const messageArea = document.getElementById('messageArea');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreDisplay = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');

    const statSukusuku = document.getElementById('statSukusuku');
    const statPartner = document.getElementById('statPartner');

    const initialMessageHtml = messageArea.innerHTML;

    let W, H;
    let groundY;
    let score = 0;
    let isGameOver = false;

    let player;
    let partner = null; // å¥³ãƒ€ãƒ³ã‚µãƒ¼
    let foods = [];
    let enemies = []; // çŠ¬ã€çˆ†å¼¾ã€é›·
    let birds = []; // é€²åŒ–ã™ã‚‹é³¥
    let dancers = []; // é™ã£ã¦ãã‚‹ãƒ€ãƒ³ã‚µãƒ¼ã‚¢ã‚¤ãƒ†ãƒ 
    let particles = [];

    // æ“ä½œé–¢é€£
    let touchStartX = 0;
    let touchStartY = 0;
    let lastTouchX = 0;
    let isTouching = false;
    let touchStartTime = 0;
    let lastTapTime = 0;
    const DOUBLE_TAP_DELAY = 300;

    // ã‚²ãƒ¼ãƒ è¨­å®š
    const MAX_LIVES = 3;
    const MAX_HEALTH = 100;

    // â˜…ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´ï¼šå…¨ä½“çš„ã«ã•ã‚‰ã«ã‚†ã£ãã‚Šã«
    const GRAVITY = 0.4;
    const FOOD_GRAVITY = 0.01; // ã•ã‚‰ã«ã‚†ã£ãã‚Š
    const FOOD_SPAWN_RATE = 1500;
    const MAX_FOODS_ON_SCREEN = 2; // åŸºæœ¬ã¯2ã¤ã¾ã§

    // ãƒ€ãƒ¡ãƒ¼ã‚¸è¨­å®š
    const DMG_DROP = 20;
    const DMG_DOG = 30;
    const DMG_LIGHTNING = 25;
    const HEAL_FOOD = 30;

    // ãƒ•ã‚£ãƒ¼ãƒãƒ¼ãƒ»çµ±è¨ˆãƒ»æ³¢
    let feverTimer = 0;            // >0 ã®é–“ãƒ•ã‚£ãƒ¼ãƒãƒ¼
    let consecutiveFullEvo = 0;    // é€£ç¶šã§ğŸ“ã«ã—ãŸå›æ•°
    let sukusukuCount = 0;         // ã™ãã™ãè‚²ã£ãŸæ•°ï¼ˆğŸ“ã«ãªã£ãŸå›æ•°ï¼‰
    let partnerGetCount = 0;       // ä»²é–“ã«ã—ãŸãƒ€ãƒ³ã‚µãƒ¼æ•°

    let waveTimer = 0;
    let waveType = 0;              // 0:ãƒ•ãƒ¼ãƒ‰ãƒ©ãƒƒã‚·ãƒ¥, 1:çŠ¬ãƒ©ãƒƒã‚·ãƒ¥, 2:é›·ãƒ»çˆ†å¼¾
    const WAVE_DURATION = 60 * 30; // ç´„30ç§’ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆ60fpsæƒ³å®šï¼‰

    // --- 2. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

    function rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randFloat(min, max) {
      return Math.random() * (max - min) + min;
    }

    function getDistance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    function circleCollision(c1, c2) {
      const dist = getDistance(c1.x, c1.y, c2.x, c2.y);
      return dist < c1.radius + c2.radius;
    }

    // ä¸­å¤®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºï¼ˆã™ãã™ããƒœãƒ¼ãƒŠã‚¹ãƒ»æ³¢ã®æ¡ˆå†…ç­‰ï¼‰
    function showMessage(text, duration = 1500) {
      messageArea.innerHTML = text;
      messageArea.style.opacity = 1;
      if (showMessage._timeoutId) clearTimeout(showMessage._timeoutId);
      showMessage._timeoutId = setTimeout(() => {
        messageArea.style.opacity = 0;
      }, duration);
    }

    // ç¾åœ¨ã®ã‚¹ã‚³ã‚¢å€ç‡ã‚’è¨ˆç®—ï¼†UIåæ˜ 
    function getCurrentMultiplier() {
      let mult = 1;
      // â˜…ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã«ã‚ˆã‚‹å€åŠ ã¯ãªã—
      // ãƒ•ã‚£ãƒ¼ãƒãƒ¼ä¸­ã ã‘3å€
      if (feverTimer > 0) mult = 3;

      if (mult > 1) {
        multiplierDisplay.textContent = `x${mult}`;
        multiplierDisplay.style.opacity = 1;
      } else {
        multiplierDisplay.textContent = '';
        multiplierDisplay.style.opacity = 0;
      }
      return mult;
    }

    // --- 3. ã‚¯ãƒ©ã‚¹å®šç¾© ---

    class Player {
      constructor() {
        this.size = 40;
        this.radius = this.size / 2;
        this.x = W / 2;
        this.y = groundY - this.radius;
        this.vx = 0;
        this.vy = 0;
        this.lives = MAX_LIVES;
        this.health = MAX_HEALTH;
        this.emoji = 'ğŸ•º';
        this.isJumping = false;
        this.isStrongJump = false;

        this.lastMoveDir = 0;
        this.invincibleTimer = 0; // ç„¡æ•µæ™‚é–“
        this.stunTimer = 0;       // éº»ç—ºæ™‚é–“

        // ãƒãƒƒã‚¯ã‚¢ã‚¦ãƒˆï¼ˆã‚„ã‚‰ã‚Œï¼‰çŠ¶æ…‹
        this.isKnockedOut = false;
      }

      draw() {
        if (this.isKnockedOut) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(Date.now() * 0.02); // ã‚„ã‚‰ã‚Œã¦ã‚‹æ™‚ã¯å›è»¢
          ctx.font = `${this.size}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('ğŸ˜µ', 0, 0); // ã‚„ã‚‰ã‚Œé¡”
          ctx.restore();
          return;
        }

        ctx.save();
        ctx.translate(this.x, this.y);

        // éº»ç—ºä¸­ã®éœ‡ãˆ
        if (this.stunTimer > 0) {
          ctx.translate(rand(-3, 3), rand(-3, 3));
          ctx.fillStyle = "yellow";
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }

        // ç„¡æ•µä¸­ã®ç‚¹æ»…
        if (this.invincibleTimer > 0) {
          if (Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.globalAlpha = 0.5;
          }
        }

        // ç§»å‹•ä¸­ã®æºã‚Œ
        if (Math.abs(this.lastMoveDir) > 0.1 && !this.isJumping && this.stunTimer <= 0) {
          ctx.rotate(Math.sin(Date.now() * 0.015) * 0.15);
        }

        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (this.isJumping && this.isStrongJump) {
          ctx.shadowBlur = 10;
          ctx.shadowColor = "orange";
        }

        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
        ctx.shadowBlur = 0;

        // lastMoveDirã®æ¸›è¡°
        this.lastMoveDir *= 0.8;
      }

      update() {
        // ãƒãƒƒã‚¯ã‚¢ã‚¦ãƒˆï¼ˆæ­»äº¡æ¼”å‡ºï¼‰ä¸­
        if (this.isKnockedOut) {
          this.vy += GRAVITY;
          this.y += this.vy;

          // ç”»é¢å¤–ã«è½ã¡ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
          if (this.y > H + 100) {
            this.respawn();
          }
          return;
        }

        if (this.invincibleTimer > 0) this.invincibleTimer--;
        if (this.stunTimer > 0) {
          this.stunTimer--;
        }

        // é‡åŠ›
        this.vy += GRAVITY;
        this.y += this.vy;

        // ç©ºä¸­åˆ¶å¾¡
        if (this.isJumping) {
          this.x += this.vx;
          this.vx *= 0.95;
        } else {
          this.vx = 0;
        }

        // åœ°é¢åˆ¤å®š
        if (this.y > groundY - this.radius) {
          this.y = groundY - this.radius;
          if (this.vy > 4) {
            this.vy = -this.vy * 0.2;
          } else {
            this.vy = 0;
            this.isJumping = false;
            this.isStrongJump = false;
          }
        }

        // å£åå°„
        if (this.x < this.radius) {
          this.x = this.radius;
          this.vx *= -0.5;
        }
        if (this.x > W - this.radius) {
          this.x = W - this.radius;
          this.vx *= -0.5;
        }
      }

      move(dx) {
        if (this.isKnockedOut || this.stunTimer > 0) return;
        // â˜…ç§»å‹•é€Ÿåº¦ã‚‚å°‘ã—ã‚†ã£ãã‚Šã« (0.7å€)
        this.x += dx * 0.7;
        this.lastMoveDir = dx * 0.7;
      }

      damageHealth(amount) {
        if (this.isKnockedOut || this.invincibleTimer > 0) return;

        this.health -= amount;
        updateStatusDisplay();
        createParticle(this.x, this.y, 'ğŸ’¢');
        if (navigator.vibrate) navigator.vibrate(200);

        if (this.health <= 0) {
          this.loseLife();
        }
      }

      loseLife() {
        if (this.isKnockedOut) return;

        this.lives--;
        updateStatusDisplay();

        if (this.lives <= 0) {
          gameOver();
        } else {
          // â˜…ã‚„ã‚‰ã‚Œæ¼”å‡ºï¼šã´ã‚‡ãƒ¼ã‚“ã¨é£›ã‚“ã§ä¸‹ã«è½ã¡ã‚‹
          this.isKnockedOut = true;
          this.vy = -12; // ä¸Šã¸è·³ã­ã‚‹
          createParticle(this.x, this.y, 'ğŸ˜±');
          if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        }
      }

      respawn() {
        // ä»•åˆ‡ã‚Šç›´ã—
        this.isKnockedOut = false;
        this.health = MAX_HEALTH;
        this.stunTimer = 0;
        this.invincibleTimer = 120; // å¾©æ´»ç›´å¾Œã¯ç„¡æ•µ
        this.x = W / 2;
        this.y = -50; // ä¸Šã‹ã‚‰é™ã£ã¦ãã‚‹
        this.vy = 0;
        this.vx = 0;
        updateStatusDisplay();
      }

      stun(frames) {
        if (this.isKnockedOut || this.invincibleTimer > 0) return;
        this.stunTimer = frames;
        createParticle(this.x, this.y, 'âš¡');
      }

      heal() {
        if (this.isKnockedOut) return;
        this.health += HEAL_FOOD;
        if (this.health > MAX_HEALTH) {
          this.health = MAX_HEALTH;
          updateScore(100);
        }
        updateStatusDisplay();
        createParticle(this.x, this.y, 'ğŸ’–');
      }

      jumpPunch(isStrong) {
        if (isGameOver || this.isKnockedOut || this.stunTimer > 0) return;

        // â˜…ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—å»ƒæ­¢ï¼šåœ°é¢ã«ã„ã‚‹ã¨ãã—ã‹ã‚¸ãƒ£ãƒ³ãƒ—ã§ããªã„
        if (this.isJumping) return;

        let jumpVx = this.lastMoveDir * 0.8;
        jumpVx = Math.max(-6, Math.min(6, jumpVx)); // æ¨ªç§»å‹•åˆ¶é™ã‚‚å°‘ã—ãã¤ã

        this.isJumping = true;
        this.isStrongJump = isStrong;
        // ã‚¸ãƒ£ãƒ³ãƒ—åŠ›ã‚‚å°‘ã—æŠ‘ãˆã‚
        this.vy = isStrong ? -14 : -9;
        this.vx = jumpVx;
        createParticle(this.x, this.y - 30, isStrong ? 'ğŸ”¥' : 'ğŸ’¨');

        // ãƒ‘ãƒ³ãƒåˆ¤å®š
        const range = isStrong ? 80 : 60;

        foods.forEach(food => {
          const dist = getDistance(this.x, this.y - 20, food.x, food.y);
          if (dist < range + food.radius) {
            let pushX = (food.x - this.x) * 0.3;
            if (Math.abs(pushX) < 2) pushX = rand(-2, 2);

            const targetHeight = this.isStrongJump ? H * 0.6 : H * 0.4;
            const jumpH = Math.max(80, targetHeight);
            const punchPowerY = -Math.sqrt(2 * FOOD_GRAVITY * jumpH);

            food.punch(pushX, punchPowerY);
            // â˜…æ‰‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ(ğŸ‘Š)ã¯ãªã—
            if (navigator.vibrate) navigator.vibrate(20);
          }
        });
      }

      eat() {
        if (isGameOver || this.isKnockedOut || this.stunTimer > 0) return;

        const eatRange = 80;

        for (let i = foods.length - 1; i >= 0; i--) {
          const f = foods[i];
          const dist = getDistance(this.x, this.y - 20, f.x, f.y);

          if (dist < eatRange) {
            this.heal();
            createParticle(this.x, this.y - 40, 'ğŸ˜‹');
            foods.splice(i, 1);
            return;
          }
        }

        for (let i = dancers.length - 1; i >= 0; i--) {
          const d = dancers[i];
          const dist = getDistance(this.x, this.y - 20, d.x, d.y);

          if (dist < eatRange) {
            partner = new Partner(this);
            partnerGetCount++; // ä»²é–“ã‚«ã‚¦ãƒ³ãƒˆ
            dancers.splice(i, 1);
            createParticle(this.x, this.y - 40, 'ğŸ¤');
            createParticle(this.x, this.y - 60, 'ğŸ’ƒ');
            updateScore(1000);
            return;
          }
        }
      }
    }

    class Partner {
      constructor(target) {
        this.target = target;
        this.x = target.x;
        this.y = target.y;
        this.size = 40;
        this.radius = this.size / 2;
        this.emoji = 'ğŸ’ƒ';
        this.lifeTime = 600;
        this.state = 'active'; // active / leaving / sacrifice
        this.alpha = 1;
      }

      takeHit() {
        if (this.state === 'sacrifice') return;
        this.state = 'sacrifice';
        this.lifeTime = 30;
        this.alpha = 1;
        this.target = null; // ã‚‚ã†è¿½å¾“ã—ãªã„
      }

      update() {
        if (this.state === 'active') {
          this.lifeTime--;
          if (this.lifeTime <= 0) {
            this.state = 'leaving';
          }
          if (this.target) {
            this.x += (this.target.x - 30 - this.x) * 0.05;
            this.y += (this.target.y - this.y) * 0.05;
          }
        } else if (this.state === 'leaving') {
          this.x -= 2;
          this.y += Math.sin(Date.now() * 0.02) * 2;
          if (this.x < -50) return 'remove';
        } else if (this.state === 'sacrifice') {
          this.lifeTime--;
          this.alpha = this.lifeTime / 30;
          if (this.lifeTime <= 0) return 'remove';
        }
        return 'alive';
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (this.state === 'sacrifice') {
          ctx.globalAlpha = this.alpha;
          ctx.font = `${this.size * 1.2}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('â¤ï¸', 0, 0);
          ctx.globalAlpha = 1;
          ctx.restore();
          return;
        }

        if (this.state === 'leaving' || (this.target && Math.abs(this.target.vx) > 0.5)) {
          ctx.rotate(Math.sin(Date.now() * 0.02) * 0.2);
        }
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
      }
    }

    class Dog {
      constructor() {
        this.direction = Math.random() < 0.5 ? 1 : -1;
        this.x = this.direction === 1 ? -50 : W + 50;
        this.y = groundY - 20;
        // â˜…çŠ¬ã®é€Ÿåº¦ã‚‚å°‘ã—ã‚†ã£ãã‚Š
        this.speed = randFloat(2, 4) * this.direction;
        this.size = 40;
        this.radius = 20; // â˜…å½“ãŸã‚Šåˆ¤å®š
        this.emoji = 'ğŸ•';
      }
      update() {
        this.x += this.speed;
        this.y = groundY - 20 + Math.sin(Date.now() * 0.02) * 5;

        if ((this.direction === 1 && this.x > W + 50) || (this.direction === -1 && this.x < -50)) {
          return 'remove';
        }

        // â˜…ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼èº«ä»£ã‚ã‚Šå„ªå…ˆ
        if (partner && partner.state === 'active' && circleCollision(this, partner)) {
          partner.takeHit();
          return 'remove';
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å½“ãŸã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸
        if (circleCollision(this, player)) {
          player.damageHealth(DMG_DOG);
          return 'remove';
        }
        return 'alive';
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.direction === 1 ? -1 : 1, 1);
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
      }
    }

    class Bomb {
      constructor() {
        this.x = rand(30, W - 30);
        this.y = -50;
        // â˜…çˆ†å¼¾ã‚‚ã•ã‚‰ã«ã‚†ã£ãã‚Š
        this.vy = randFloat(0.7, 1.5);
        this.size = 40;
        this.radius = 18;
        this.emoji = 'ğŸ’£';
        this.rotation = 0;
      }
      update() {
        this.y += this.vy;
        this.rotation += 0.05;

        if (this.y > groundY) {
          createParticle(this.x, this.y, 'ğŸ’¥');
          return 'remove';
        }

        // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼èº«ä»£ã‚ã‚Š
        if (partner && partner.state === 'active' && circleCollision(this, partner)) {
          partner.takeHit();
          return 'remove';
        }

        if (circleCollision(this, player)) {
          player.loseLife();
          return 'remove';
        }
        return 'alive';
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
      }
    }

    class Lightning {
      constructor() {
        this.x = rand(20, W - 20);
        this.y = -50;
        this.size = 40;
        this.radius = 15;
        this.speedY = 1.5; // ã•ã‚‰ã«ã‚†ã£ãã‚Š
        this.emoji = 'âš¡';
      }
      update() {
        this.y += this.speedY;
        this.x += Math.sin(this.y * 0.05) * 2;

        if (this.y > groundY) return 'remove';

        // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼èº«ä»£ã‚ã‚Š
        if (partner && partner.state === 'active' && circleCollision(this, partner)) {
          partner.takeHit();
          return 'remove';
        }

        if (circleCollision(this, player)) {
          player.damageHealth(DMG_LIGHTNING);
          player.stun(90);
          return 'remove';
        }
        return 'alive';
      }
      draw() {
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'yellow';
        ctx.fillText(this.emoji, this.x, this.y);
        ctx.shadowBlur = 0;
      }
    }

    class Food {
      constructor() {
        this.radius = 15;
        this.x = rand(this.radius + 10, W - this.radius - 10);
        this.y = -30;
        this.vx = 0;
        this.vy = randFloat(0.2, 0.5); // è½ä¸‹é€Ÿåº¦ã•ã‚‰ã«ã‚†ã£ãã‚Š
        this.emoji = ['ğŸ', 'ğŸ¥¦', 'ğŸ”', 'ğŸ°', 'ğŸ™'][rand(0, 4)];
        this.rotation = 0;
        this.rotSpeed = 0;
        this.isPunched = false;

        this.hitStop = 0;
        this.pendingVx = 0;
        this.pendingVy = 0;
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.hitStop > 0) {
          ctx.translate(rand(-2, 2), rand(-2, 2));
        }
        ctx.rotate(this.rotation);
        ctx.font = `${this.radius * 2}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // â˜…ãƒ•ã‚£ãƒ¼ãƒãƒ¼ä¸­ã¯å…¨éƒ¨ã‚«ãƒ¬ãƒ¼ã«è¦‹ãˆã‚‹
        const emojiToDraw = (feverTimer > 0) ? 'ğŸ›' : this.emoji;
        ctx.fillText(emojiToDraw, 0, 0);
        ctx.restore();
      }

      update() {
        if (this.hitStop > 0) {
          this.hitStop--;
          if (this.hitStop === 0) {
            this.vx = this.pendingVx;
            this.vy = this.pendingVy;
            this.rotSpeed = rand(-0.2, 0.2);
            this.isPunched = true;
          }
          return 'alive';
        }

        if (this.x < this.radius) {
          this.x = this.radius;
          this.vx *= -0.8;
        } else if (this.x > W - this.radius) {
          this.x = W - this.radius;
          this.vx *= -0.8;
        }

        this.vy += FOOD_GRAVITY;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotSpeed;
        this.vx *= 0.99;

        if (this.y >= groundY - this.radius) {
          createParticle(this.x, this.y, 'ğŸ’¨');
          // â˜…ãƒ•ã‚£ãƒ¼ãƒãƒ¼ä¸­ã¯è½ã¡ã¦ã‚‚ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã—
          if (feverTimer <= 0) {
            createParticle(this.x, this.y - 20, 'ğŸ’”');
            player.damageHealth(DMG_DROP);
          }
          return 'remove';
        }
        return 'alive';
      }

      punch(vx, vy) {
        this.hitStop = 6;
        this.pendingVx = vx;
        this.pendingVy = vy;
      }
    }

    class FallingDancer {
      constructor() {
        this.x = rand(50, W - 50);
        this.y = -50;
        this.vy = 1.0; // ã‚†ã£ãã‚Š
        this.rotation = 0;
        this.size = 40;
        this.emoji = 'ğŸ’ƒ';
      }
      update() {
        this.y += this.vy;
        this.rotation += 0.05;
        if (this.y > groundY) return 'remove';
        return 'alive';
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
      }
    }

    class EvoBird {
      constructor() {
        this.stage = 0;
        this.emojis = ['ğŸ£', 'ğŸ¥', 'ğŸ“'];
        this.size = 35;
        this.radius = 20;
        this.resetPosition();
      }

      resetPosition() {
        this.y = rand(H * 0.2, H * 0.6);
        this.direction = Math.random() < 0.5 ? 1 : -1;
        this.x = this.direction === 1 ? -30 : W + 30;
        this.baseY = this.y;
        this.swingPhase = rand(0, 100);
        this.speed = randFloat(0.5, 1.5); // é³¥ã®å‹•ãã‚‚ã‚†ã£ãã‚Š
        this.state = 'moving';
      }

      update() {
        if (this.state === 'flying_away') {
          this.x += this.speed * this.direction * 1.5;
          this.y -= 1.5;
          if (this.y < -50 || this.x < -50 || this.x > W + 50) {
            this.stage = 0;
            this.state = 'moving';
            this.resetPosition();
          }
          return;
        }

        this.x += this.speed * this.direction;
        this.swingPhase += 0.05;
        this.y = this.baseY + Math.sin(this.swingPhase) * 15;

        if ((this.direction === 1 && this.x > W + 50) || (this.direction === -1 && this.x < -50)) {
          this.direction *= -1;
          this.baseY = rand(H * 0.2, H * 0.6);
        }

        // é£Ÿã¹ç‰©ã‚­ãƒ£ãƒƒãƒ
        foods.forEach(f => {
          if (f.isPunched && circleCollision(this, f)) {
            f.y = -999;
            const basePts = this.stage * 200 + 100;
            createParticle(this.x, this.y, 'âœ¨');
            updateScore(basePts);

            if (this.stage < 2) {
              this.stage++;
              if (this.stage === 2) {
                // ğŸ“ã«ãªã£ãŸç¬é–“
                this.state = 'flying_away';
                createParticle(this.x, this.y, 'ğŸ“ğŸ’¨');
                updateScore(1000); // ã™ãã™ãæœ¬ä½“åˆ†
                sukusukuCount++;
                showMessage('ã™ãã™ããƒœãƒ¼ãƒŠã‚¹ï¼+1000', 1500);

                consecutiveFullEvo++;
                if (consecutiveFullEvo >= 3) {
                  // â˜…ãƒ•ã‚£ãƒ¼ãƒãƒ¼çªå…¥
                  feverTimer = 600; // ç´„10ç§’
                  consecutiveFullEvo = 0;
                  showMessage('ãƒ•ã‚£ãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ ï¼', 1500);
                }
              }
            }
          }
        });
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.direction === 1 ? -1 : 1, 1);
        ctx.font = `${this.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emojis[this.stage], 0, 0);
        ctx.restore();
      }
    }

    class Particle {
      constructor(x, y, emoji) {
        this.x = x;
        this.y = y;
        this.emoji = emoji;
        this.life = 30;
        this.vy = -1.0; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚‚å°‘ã—ã‚†ã£ãã‚Š
      }
      update() {
        this.y += this.vy;
        this.life--;
      }
      draw() {
        ctx.globalAlpha = this.life / 30;
        ctx.font = '25px Arial';
        ctx.fillText(this.emoji, this.x, this.y);
        ctx.globalAlpha = 1.0;
      }
    }

    // --- 4. ãƒ¡ã‚¤ãƒ³å‡¦ç† ---

    function init() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      groundY = H - 80;

      score = 0;
      isGameOver = false;

      feverTimer = 0;
      consecutiveFullEvo = 0;
      sukusukuCount = 0;
      partnerGetCount = 0;
      waveTimer = 0;
      waveType = 0;

      foods = [];
      enemies = [];
      dancers = [];
      birds = [];
      particles = [];
      partner = null;

      gameOverScreen.style.display = 'none';

      // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¯å›å¾©å…ƒ
      messageArea.innerHTML = initialMessageHtml;
      messageArea.style.opacity = 1;
      setTimeout(() => { messageArea.style.opacity = 0; }, 6000);

      player = new Player();
      updateStatusDisplay();

      birds.push(new EvoBird());
      setTimeout(() => { birds.push(new EvoBird()); }, 2000);

      if (window.gameLoopId) cancelAnimationFrame(window.gameLoopId);
      if (window.spawnTimer) clearInterval(window.spawnTimer);

      window.spawnTimer = setInterval(() => {
        if (!isGameOver && !player.isKnockedOut) {
          spawnManager();
        }
      }, 1000);

      loop();
    }

    function spawnManager() {
      // æ³¢ã«ã‚ˆã‚‹å‡ºç¾ç‡èª¿æ•´
      let foodChance = 0.7;
      let dogChance = 0.02;
      let bombChance = 0.03;
      let lightningChance = 0.01;
      let dancerChance = 0.02;

      if (waveType === 0) {           // ãƒ•ãƒ¼ãƒ‰ãƒ©ãƒƒã‚·ãƒ¥
        foodChance = 0.95;
        dogChance = 0.01;
        bombChance = 0.01;
        lightningChance = 0.005;
        dancerChance = 0.02;
      } else if (waveType === 1) {    // çŠ¬ãƒ©ãƒƒã‚·ãƒ¥
        foodChance = 0.6;
        dogChance = 0.10; // çŠ¬å¤šã‚
        bombChance = 0.01;
        lightningChance = 0.005;
        dancerChance = 0.03;
      } else if (waveType === 2) {    // é›·ãƒ»çˆ†å¼¾ã‚¿ã‚¤ãƒ 
        foodChance = 0.7;
        dogChance = 0.02;
        bombChance = 0.08;  // çˆ†å¼¾å¤šã‚
        lightningChance = 0.05; // é›·å¤šã‚
        dancerChance = 0.03;
      }

      // é£Ÿã¹ç‰©ï¼ˆåŸºæœ¬ã¯2ã¤ã¾ã§ã€ãƒ•ã‚£ãƒ¼ãƒãƒ¼ or ãƒ•ãƒ¼ãƒ‰ãƒ©ãƒƒã‚·ãƒ¥ä¸­ã¯ãŸãã•ã‚“ï¼‰
      let maxFoods = MAX_FOODS_ON_SCREEN;
      if (feverTimer > 0 || waveType === 0) {
        maxFoods = 8; // â˜…åˆ¶é™è§£é™¤ã§ãŸãã•ã‚“
      }

      if (foods.length < maxFoods && Math.random() < foodChance) {
        foods.push(new Food());
      }

      // æ•µã‚­ãƒ£ãƒ©å‡ºç¾æŠ½é¸
      const r = Math.random();
      if (r < dogChance) {
        enemies.push(new Dog());
      } else if (r < dogChance + bombChance) {
        enemies.push(new Bomb());
      } else if (r < dogChance + bombChance + lightningChance) {
        const hasLightning = enemies.some(e => e instanceof Lightning);
        if (!hasLightning) {
          enemies.push(new Lightning());
        }
      } else if (r < dogChance + bombChance + lightningChance + dancerChance) {
        dancers.push(new FallingDancer());
      }
    }

    function updateStatusDisplay() {
      let hearts = '';
      for (let i = 0; i < player.lives; i++) hearts += 'â¤ï¸';
      lifeContainer.textContent = hearts;

      const percent = Math.max(0, player.health / MAX_HEALTH);
      healthBar.style.width = `${percent * 100}%`;
      if (percent < 0.3) healthBar.style.backgroundColor = '#d9534f';
      else if (percent < 0.6) healthBar.style.backgroundColor = '#f0ad4e';
      else healthBar.style.backgroundColor = '#4CAF50';
    }

    function updateScore(pts) {
      const mult = getCurrentMultiplier();
      score += pts * mult;
      scoreDisplay.textContent = score;
    }

    function createParticle(x, y, e) {
      particles.push(new Particle(x, y, e));
    }

    function loop() {
      if (isGameOver) return;

      // ãƒ•ã‚£ãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒãƒ¼æ¸›å°‘
      if (feverTimer > 0) {
        feverTimer--;
      }

      // æ³¢ã‚¿ã‚¤ãƒãƒ¼
      waveTimer++;
      if (waveTimer > WAVE_DURATION) {
        waveTimer = 0;
        waveType = (waveType + 1) % 3;
        if (waveType === 0) {
          showMessage('ãƒ•ãƒ¼ãƒ‰ãƒ©ãƒƒã‚·ãƒ¥ï¼', 1200);
        } else if (waveType === 1) {
          showMessage('çŠ¬ãƒ©ãƒƒã‚·ãƒ¥ï¼', 1200);
        } else {
          showMessage('é›·ãƒ»çˆ†å¼¾ã‚¿ã‚¤ãƒ ï¼', 1200);
        }
      }

      ctx.clearRect(0, 0, W, H);

      // èƒŒæ™¯ãƒ»åœ°é¢
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(0, groundY, W, H - groundY);
      ctx.fillStyle = '#228B22';
      ctx.fillRect(0, groundY, W, 15);

      // æ•µ
      for (let i = enemies.length - 1; i >= 0; i--) {
        const res = enemies[i].update();
        if (res === 'remove') enemies.splice(i, 1);
        else enemies[i].draw();
      }

      // è½ã¡ã¦ãã‚‹ãƒ€ãƒ³ã‚µãƒ¼
      for (let i = dancers.length - 1; i >= 0; i--) {
        const res = dancers[i].update();
        if (res === 'remove') dancers.splice(i, 1);
        else dancers[i].draw();
      }

      // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼
      if (partner) {
        const res = partner.update();
        if (res === 'remove') partner = null;
        else partner.draw();
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      player.update();
      player.draw();

      // é³¥
      birds.forEach(b => { b.update(); b.draw(); });

      // é£Ÿã¹ç‰©
      for (let i = foods.length - 1; i >= 0; i--) {
        const res = foods[i].update();
        if (res === 'remove' || foods[i].y > H + 50) {
          foods.splice(i, 1);
        } else {
          foods[i].draw();
        }
      }

      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      // é•·æŠ¼ã—å‡¦ç†
      if (isTouching && !isSwiping) {
        if (Date.now() - touchStartTime > 300) {
          player.eat();
        }
      }

      // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å€ç‡UIã ã‘ã¯æ›´æ–°ã—ã¦ãŠã
      getCurrentMultiplier();

      window.gameLoopId = requestAnimationFrame(loop);
    }

    function gameOver() {
      isGameOver = true;
      clearInterval(window.spawnTimer);
      finalScoreDisplay.textContent = `SCORE: ${score}`;
      statSukusuku.textContent = sukusukuCount;
      statPartner.textContent = partnerGetCount;
      gameOverScreen.style.display = 'block';
    }

    // --- 5. ã‚¤ãƒ™ãƒ³ãƒˆ ---

    restartButton.addEventListener('click', init);

    let isSwiping = false;

    function getPoint(e) {
      if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }

    function handleStart(e) {
      e.preventDefault();
      if (isGameOver) return;

      const p = getPoint(e);
      touchStartX = p.x;
      touchStartY = p.y;
      lastTouchX = p.x;
      isTouching = true;
      isSwiping = false;

      touchStartTime = Date.now();
    }

    function handleMove(e) {
      e.preventDefault();
      if (e.type === 'mousemove' && !isTouching) return;
      if (isGameOver || !isTouching) return;

      const p = getPoint(e);
      const deltaX = p.x - lastTouchX;
      if (Math.abs(deltaX) > 2) isSwiping = true;

      player.move(deltaX);
      lastTouchX = p.x;
    }

    function handleEnd(e) {
      e.preventDefault();
      if (isGameOver) return;

      isTouching = false;

      let endX, endY;
      if (e.changedTouches && e.changedTouches.length > 0) {
        endX = e.changedTouches[0].clientX;
        endY = e.changedTouches[0].clientY;
      } else {
        endX = e.clientX;
        endY = e.clientY;
      }

      const diffY = endY - touchStartY;
      const diffX = endX - touchStartX;
      const dist = Math.sqrt(diffX * diffX + diffY * diffY);

      if (dist < 20) {
        const now = new Date().getTime();
        if (now - lastTapTime < DOUBLE_TAP_DELAY) {
          player.jumpPunch(true);
          lastTapTime = 0;
        } else {
          player.jumpPunch(false);
          lastTapTime = now;
        }
      }
    }

    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', () => isTouching = false);

    window.addEventListener('resize', () => {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      groundY = H - 80;
      if (player) player.y = groundY - player.radius;
    });

    init();
  })();
  </script>
</body>
</html>

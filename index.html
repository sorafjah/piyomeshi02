<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„Éî„É®È£Ø - Piyo Meshi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f9ff; /* Á©∫Ëâ≤ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* „É¢„Éê„Ç§„É´„Åß„ÅÆ„Çπ„ÇØ„É≠„Éº„É´Èò≤Ê≠¢ */
            user-select: none;
            -webkit-user-select: none;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        /* UI„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* „Ç≤„Éº„É†Êìç‰Ωú„ÇíÈÇ™È≠î„Åó„Å™„ÅÑ */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .top-bar {
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .score-board {
            font-size: 24px;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 20px;
        }
        .life-container {
            font-size: 24px;
        }
        .stamina-container {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 150px;
        }
        .stamina-label {
            font-size: 12px;
            color: #333;
            font-weight: bold;
            margin-bottom: 2px;
        }
        .stamina-bar-bg {
            width: 100%;
            height: 15px;
            background: #ddd;
            border-radius: 8px;
            border: 2px solid #fff;
            overflow: hidden;
        }
        .stamina-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #facc15, #ea580c);
            width: 100%;
            transition: width 0.1s;
        }
        
        /* ÁîªÈù¢„Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫ (WaveÂêç„Å™„Å©) */
        #waveDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px #000;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }

        /* ÁîªÈù¢„Ç™„Éº„Éê„Éº„É¨„Ç§ („Çπ„Çø„Éº„Éà/„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº) */
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
            color: white;
            text-align: center;
        }
        .hidden { display: none !important; }
        
        .btn {
            background: linear-gradient(to bottom, #4ade80, #16a34a);
            border: 4px solid #fff;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* „Éï„Ç£„Éº„Éê„ÉºÊºîÂá∫Áî® */
        .fever-bg {
            animation: rainbow 5s infinite linear;
        }
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div class="ui-layer">
        <div class="top-bar">
            <div class="stamina-container">
                <div class="stamina-label">üí™ MUSCLE (‰ΩìÂäõ)</div>
                <div class="stamina-bar-bg">
                    <div id="staminaFill" class="stamina-bar-fill"></div>
                </div>
            </div>
            <div class="score-board">SCORE: <span id="scoreVal">0</span></div>
            <div class="life-container" id="lifeContainer">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
    </div>

    <!-- Center Text Notification -->
    <div id="waveDisplay">WAVE START!</div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen-overlay">
        <h1 class="text-6xl mb-4 font-black text-yellow-400 drop-shadow-lg">„Éî„É®È£Ø</h1>
        <p class="text-xl mb-8">Piyo-Meshi</p>
        <div class="bg-white/20 p-4 rounded-lg text-left text-sm mb-6 max-w-xs">
            <p>üëÜ <b>„Çø„ÉÉ„Éó</b>: „Ç∏„É£„É≥„Éó & „Éë„É≥„ÉÅ</p>
            <p>‚ÜîÔ∏è <b>„Çπ„ÉØ„Ç§„Éó</b>: ÁßªÂãï</p>
            <p>üëá <b>Èï∑Êäº„Åó</b>: È£ü„Åπ„Å¶‰ΩìÂäõÂõûÂæ©</p>
            <hr class="my-2 border-white/30">
            <p>üçé„Çí„Éë„É≥„ÉÅ„Åó„Å¶üê£„Å´È£ü„Åπ„Åï„Åõ„Çà„ÅÜÔºÅ</p>
        </div>
        <button class="btn" onclick="startGame()">START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen-overlay hidden">
        <h2 class="text-5xl font-bold text-red-500 mb-2">GAME OVER</h2>
        <div class="bg-white/10 p-6 rounded-xl w-80">
            <div class="flex justify-between mb-2">
                <span>SCORE:</span>
                <span id="finalScore" class="font-bold text-2xl">0</span>
            </div>
            <div class="flex justify-between mb-2">
                <span>üêì ËÇ≤„Å¶„ÅüÊï∞:</span>
                <span id="finalRoosters" class="font-bold">0</span>
            </div>
            <div class="flex justify-between mb-2">
                <span>üíÉ ‰ª≤Èñì:</span>
                <span id="finalDancers" class="font-bold">0</span>
            </div>
            <hr class="my-4 border-white/30">
            <div class="text-center text-yellow-300 text-sm mb-1">HIGH SCORE</div>
            <div id="highScoreDisplay" class="text-center text-3xl font-black">0</div>
        </div>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>

<script>
/* =================================================================
   CORE GAME CONSTANTS & VARIABLES
   =================================================================
*/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let SCREEN_W, SCREEN_H;

// Game State
let gameState = 'start'; // start, playing, gameover
let frames = 0;
let score = 0;
let highScore = localStorage.getItem('piyoMeshiHighScore') || 0;
let lives = 3;
let maxStamina = 100;
let stamina = 100;
let gameTime = 0; // in seconds
let waveTimer = 0;
let currentWave = 0; // 0:Food, 1:Dog, 2:Thunder/Bomb
const WAVE_CYCLE = 30; // seconds

// Fever
let roostersRaisedCycle = 0; // Count for fever trigger
let feverMode = false;
let feverTimer = 0;
let roostersTotal = 0;
let dancersCollected = 0;

// Entities
let player;
let chicks = [];
let foods = [];
let enemies = [];
let dancers = [];
let particles = [];
let popups = [];

// Input Handling
let touchStartX = 0;
let touchStartY = 0;
let isTouching = false;
let holdTimer = 0;
let isHolding = false;
const HOLD_THRESHOLD = 15; // frames until hold registers

// Assets (Emojis)
const IMG_PLAYER = 'üï∫'; // Stick figure/Dancer
const IMG_PLAYER_PUNCH = 'ü•ä';
const IMG_PLAYER_EAT = 'üòã';
const IMG_PLAYER_HIT = 'üòµ';
const IMG_FOOD_APPLE = 'üçé';
const IMG_FOOD_CURRY = 'üçõ';
const IMG_CHICK_EGG = 'ü•ö';
const IMG_CHICK_BABY = 'üê£';
const IMG_CHICK_ADULT = 'üêì';
const IMG_DOG = 'üêï';
const IMG_LIGHTNING = '‚ö°';
const IMG_BOMB = 'üí£';
const IMG_DANCER = 'üíÉ';

/* =================================================================
   CLASSES
   =================================================================
*/

class Player {
    constructor() {
        this.w = 60;
        this.h = 80;
        this.x = SCREEN_W / 2 - this.w / 2;
        this.y = SCREEN_H - this.h - 20;
        this.groundY = SCREEN_H - this.h - 20;
        this.vx = 0;
        this.vy = 0;
        this.isJumping = false;
        this.isPunching = false;
        this.state = 'idle'; // idle, jump, punch, eat, hit
        this.invincible = 0;
        this.dancerStack = 0; // Number of dancers following
    }

    update() {
        // Movement Smoothing
        this.x += this.vx;
        
        // Boundary
        if (this.x < 0) this.x = 0;
        if (this.x > SCREEN_W - this.w) this.x = SCREEN_W - this.w;

        // Gravity / Jump
        if (this.isJumping) {
            this.y += this.vy;
            this.vy += 1.5; // Gravity
            
            if (this.y >= this.groundY) {
                this.y = this.groundY;
                this.isJumping = false;
                this.isPunching = false;
                this.state = 'idle';
            }
        }

        // Friction for horizontal move
        this.vx *= 0.8; 

        // Stamina mechanic logic handled in main loop

        if (this.invincible > 0) this.invincible--;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        
        if (this.invincible > 0 && Math.floor(frames / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        let char = IMG_PLAYER;
        if (this.state === 'hit') char = IMG_PLAYER_HIT;
        else if (isHolding) char = IMG_PLAYER_EAT;
        else if (this.isPunching) char = IMG_PLAYER_PUNCH;

        // Draw Player
        ctx.font = `${this.h}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char, 0, 0);

        // Draw Muscle Arm (Visual Feedback for Punch)
        if (this.isPunching) {
            ctx.font = '40px serif';
            ctx.fillText('üí™', 0, -this.h/2 - 10);
        }

        // Draw Dancers (Shields)
        for (let i = 0; i < this.dancerStack; i++) {
            let angle = (frames * 0.1) + (i * (Math.PI * 2 / this.dancerStack));
            let dist = 50;
            let dx = Math.cos(angle) * dist;
            let dy = Math.sin(angle) * dist;
            ctx.font = '30px serif';
            ctx.fillText(IMG_DANCER, dx, dy);
        }

        ctx.restore();
    }

    jump() {
        if (!this.isJumping && this.state !== 'hit') {
            this.vy = -22;
            this.isJumping = true;
            this.isPunching = true;
            this.state = 'jump';
            decreaseStamina(5);
            createParticles(this.x + this.w/2, this.y + this.h, 'dust');
        }
    }

    hit() {
        if (feverMode) return; // No damage in fever
        if (this.invincible > 0) return;

        // If has dancer, sacrifice one
        if (this.dancerStack > 0) {
            this.dancerStack--;
            addPopup(this.x, this.y, "SHIELD!", "#ff69b4");
            this.invincible = 60;
            createParticles(this.x, this.y, 'heart');
            return;
        }

        // Normal damage
        decreaseStamina(20);
        this.state = 'hit';
        this.vy = -10;
        this.isJumping = true; // Knockback jump
        this.invincible = 60;
        ctx.fillStyle = 'rgba(255,0,0,0.3)';
        ctx.fillRect(0,0,SCREEN_W, SCREEN_H); // Flash screen
    }
}

class Chick {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.baseY = y;
        this.w = 50;
        this.h = 50;
        this.stage = 0; // 0:Egg, 1:Chick, 2:Rooster
        this.moveSpeed = Math.random() * 2 + 1;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.foodEaten = 0;
    }

    update() {
        // Move
        this.x += this.moveSpeed * this.direction;
        
        // Bounce on walls
        if (this.x < 0 || this.x > SCREEN_W - this.w) {
            this.direction *= -1;
        }

        // Bobbing
        this.y = this.baseY + Math.sin(frames * 0.1) * 10;
    }

    draw() {
        let char = IMG_CHICK_EGG;
        if (this.stage === 1) char = IMG_CHICK_BABY;
        if (this.stage === 2) char = IMG_CHICK_ADULT;

        ctx.font = `${this.h}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        // Flip if moving left
        if (this.direction < 0) ctx.scale(-1, 1);
        ctx.fillText(char, 0, 0);
        ctx.restore();
    }

    feed() {
        this.foodEaten++;
        score += 100;
        addPopup(this.x, this.y, "+100", "#ffd700");
        
        // Growth Logic
        if (this.stage === 0) {
            this.stage = 1;
            createParticles(this.x, this.y, 'sparkle');
        } else if (this.stage === 1) {
            if (this.foodEaten >= 3) { // Needs 2 more meals (total 3)
                this.stage = 2;
                createParticles(this.x, this.y, 'sparkle');
                
                // Rooster Bonus
                setTimeout(() => {
                    score += 1000;
                    roostersRaisedCycle++;
                    roostersTotal++;
                    addPopup(this.x, this.y, "SUKU-SUKU! +1000", "#ff4500", 40);
                    this.flyAway();
                }, 500);
            }
        }
    }

    flyAway() {
        // Simple animation effect logic would go here, but for simplicity, we replace it immediately
        // In a full game, we'd animate it flying up
        this.reset();
        checkFever();
    }

    reset() {
        this.stage = 0;
        this.foodEaten = 0;
        this.x = Math.random() * (SCREEN_W - 100);
        // Effect
        createParticles(this.x, this.y, 'smoke');
    }
}

class Food {
    constructor() {
        this.w = 40;
        this.h = 40;
        this.x = Math.random() * (SCREEN_W - this.w);
        this.y = -50;
        this.vy = Math.random() * 2 + 2; // Falling speed
        this.state = 'falling'; // falling, rising
        this.type = feverMode ? 'curry' : 'apple';
    }

    update() {
        if (this.state === 'falling') {
            this.y += this.vy;
            // Ground hit
            if (this.y > SCREEN_H - 50) {
                createParticles(this.x, this.y, 'splash');
                decreaseStamina(10);
                return false; // Remove
            }
        } else if (this.state === 'rising') {
            this.y += this.vy; // vy is negative
            // Check boundary top
            if (this.y < 50) {
                // Check collision with chicks handled in main loop
                if (this.y < 0) return false; // Missed chick
            }
        }
        return true;
    }

    draw() {
        ctx.font = `${this.w}px serif`;
        ctx.textAlign = 'center';
        ctx.fillText(this.type === 'apple' ? IMG_FOOD_APPLE : IMG_FOOD_CURRY, this.x + this.w/2, this.y + this.h/2);
    }
}

class Enemy {
    constructor(type) {
        this.type = type; // dog, lightning, bomb
        this.w = 50;
        this.h = 50;
        
        if (type === 'dog') {
            this.y = SCREEN_H - 70;
            this.speed = 4 + (currentWave * 1); // Faster in later waves
            if (Math.random() > 0.5) {
                this.x = -60;
                this.vx = this.speed;
            } else {
                this.x = SCREEN_W + 10;
                this.vx = -this.speed;
            }
        } else if (type === 'lightning' || type === 'bomb') {
            this.x = Math.random() * (SCREEN_W - this.w);
            this.y = -60;
            this.vy = 5;
        }
    }

    update() {
        if (this.type === 'dog') {
            this.x += this.vx;
            this.y = SCREEN_H - 70 + Math.sin(frames * 0.5) * 5; // Shake
            if (this.x > SCREEN_W + 100 || this.x < -100) return false;
        } else {
            this.y += this.vy;
            if (this.y > SCREEN_H) return false;
        }
        return true;
    }

    draw() {
        let char = IMG_DOG;
        if (this.type === 'lightning') char = IMG_LIGHTNING;
        if (this.type === 'bomb') char = IMG_BOMB;

        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        if (this.type === 'dog' && this.vx < 0) ctx.scale(-1, 1);
        ctx.font = `${this.w}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(char, 0, 0);
        ctx.restore();
    }
}

class Dancer {
    constructor() {
        this.w = 40;
        this.h = 60;
        this.x = Math.random() * (SCREEN_W - this.w);
        this.y = -60;
        this.vy = 2;
        this.angle = 0;
    }
    
    update() {
        this.y += this.vy;
        this.angle += 0.1;
        if (this.y > SCREEN_H) return false;
        return true;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.rotate(this.angle);
        ctx.font = '40px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(IMG_DANCER, 0, 0);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.life = 30;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.size = Math.random() * 10 + 5;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.9;
    }
    draw() {
        ctx.globalAlpha = this.life / 30;
        if (this.type === 'text') return; // Handled by Popup

        if (this.type === 'dust') ctx.fillStyle = '#aaa';
        else if (this.type === 'splash') ctx.fillStyle = 'rgba(200,50,50,0.8)';
        else if (this.type === 'sparkle') ctx.fillStyle = '#ffd700';
        else if (this.type === 'heart') ctx.fillStyle = '#ff69b4';
        else ctx.fillStyle = '#fff';

        ctx.beginPath();
        if (this.type === 'heart') {
             ctx.font = `${this.size}px serif`;
             ctx.fillText('‚ù§Ô∏è', this.x, this.y);
        } else {
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }
}

class Popup {
    constructor(x, y, text, color, size = 20) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 40;
        this.size = size;
    }
    update() {
        this.y -= 2;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = Math.min(1, this.life / 10);
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.font = `bold ${this.size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

/* =================================================================
   GAME LOGIC & FUNCTIONS
   =================================================================
*/

function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // Input Listeners
    window.addEventListener('touchstart', handleTouchStart, {passive: false});
    window.addEventListener('touchmove', handleTouchMove, {passive: false});
    window.addEventListener('touchend', handleTouchEnd, {passive: false});
    
    // Mouse fallback
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    
    // Initial rendering
    ctx.fillStyle = '#f0f9ff';
    ctx.fillRect(0,0,SCREEN_W, SCREEN_H);
    
    updateUI();
    updateHighScore();
}

function resize() {
    SCREEN_W = window.innerWidth;
    SCREEN_H = window.innerHeight;
    canvas.width = SCREEN_W;
    canvas.height = SCREEN_H;
    if(player) player.groundY = SCREEN_H - player.h - 20;
}

function startGame() {
    score = 0;
    lives = 3;
    stamina = 100;
    gameTime = 0;
    roostersRaisedCycle = 0;
    roostersTotal = 0;
    dancersCollected = 0;
    currentWave = 0;
    feverMode = false;
    
    player = new Player();
    chicks = [new Chick(SCREEN_W * 0.2, 80), new Chick(SCREEN_W * 0.7, 100)];
    foods = [];
    enemies = [];
    dancers = [];
    particles = [];
    popups = [];
    
    gameState = 'playing';
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.querySelector('body').classList.remove('fever-bg');
    
    showWaveText("WAVE 1: FOOD RUSH!");
    loop();
}

function resetGame() {
    startGame();
}

function showWaveText(text) {
    const el = document.getElementById('waveDisplay');
    el.innerText = text;
    el.style.opacity = 1;
    setTimeout(() => { el.style.opacity = 0; }, 2000);
}

function loop() {
    if (gameState !== 'playing') return;
    requestAnimationFrame(loop);
    
    ctx.clearRect(0, 0, SCREEN_W, SCREEN_H);
    frames++;
    
    // Game Logic
    if (frames % 60 === 0) {
        gameTime++;
        waveTimer++;
        
        // Wave Management
        let waveCycleTime = gameTime % WAVE_CYCLE;
        if (waveCycleTime === 0) {
            currentWave = (currentWave + 1) % 3;
            let waveName = ["FOOD RUSH!", "DOG RUSH!", "DANGER ZONE!"][currentWave];
            showWaveText(`WAVE ${Math.floor(gameTime/30) + 1}: ${waveName}`);
        }
    }

    // Fever Logic
    if (feverMode) {
        feverTimer--;
        if (feverTimer <= 0) {
            feverMode = false;
            document.querySelector('body').classList.remove('fever-bg');
            showWaveText("FEVER END");
        }
        ctx.fillStyle = `rgba(255, 255, 0, ${0.1 + Math.sin(frames * 0.2)*0.1})`;
        ctx.fillRect(0,0,SCREEN_W, SCREEN_H);
    }
    
    spawnManager();
    updateEntities();
    drawEntities();
    
    // Input Hold Logic (Eat)
    if (isTouching) {
        holdTimer++;
        if (holdTimer > HOLD_THRESHOLD) {
            isHolding = true;
            player.state = 'eat';
            checkEatCollision();
        }
    } else {
        holdTimer = 0;
        isHolding = false;
        if (player.state === 'eat') player.state = 'idle';
    }

    updateUI();
}

function spawnManager() {
    // Food Spawning
    let maxFood = feverMode ? 10 : (currentWave === 0 ? 5 : 2);
    let spawnRate = feverMode ? 0.1 : (currentWave === 0 ? 0.05 : 0.02);
    
    if (foods.length < maxFood && Math.random() < spawnRate) {
        foods.push(new Food());
    }

    // Enemy Spawning
    if (!feverMode) {
        // Dogs (More in Wave 1: Index 1)
        if (currentWave === 1 && Math.random() < 0.02) enemies.push(new Enemy('dog'));
        else if (Math.random() < 0.005) enemies.push(new Enemy('dog'));

        // Thunder/Bomb (More in Wave 2: Index 2)
        if (currentWave === 2) {
            if (Math.random() < 0.01) enemies.push(new Enemy('lightning'));
            if (Math.random() < 0.01) enemies.push(new Enemy('bomb'));
        } else {
            if (Math.random() < 0.002) enemies.push(new Enemy('lightning'));
            if (Math.random() < 0.002) enemies.push(new Enemy('bomb'));
        }
    }

    // Dancer Spawning
    if (Math.random() < 0.001) dancers.push(new Dancer());
}

function updateEntities() {
    player.update();
    
    // Chicks
    chicks.forEach(c => c.update());
    
    // Food
    foods = foods.filter(f => {
        let active = f.update();
        
        // Collision with Player Punch
        if (active && f.state === 'falling' && player.isPunching) {
            // Check overlap. Player punch box is above head
            if (Math.abs((player.x + player.w/2) - (f.x + f.w/2)) < 50 &&
                f.y + f.h > player.y - 20 && f.y < player.y + player.h) {
                
                f.state = 'rising';
                f.vy = -15; // Fly up
                createParticles(f.x + f.w/2, f.y + f.h/2, 'dust');
                addPopup(f.x, f.y, "PUNCH!", "#fff", 15);
                
                // Vibration
                if(navigator.vibrate) navigator.vibrate(20);
            }
        }
        
        // Collision with Chicks (Feeding)
        if (active && f.state === 'rising') {
            for (let c of chicks) {
                if (Math.abs((c.x + c.w/2) - (f.x + f.w/2)) < 40 &&
                    Math.abs((c.y + c.h/2) - (f.y + f.h/2)) < 40) {
                    c.feed();
                    return false; // Eaten
                }
            }
        }
        return active;
    });

    // Enemies
    enemies = enemies.filter(e => {
        let active = e.update();
        
        // Collision Player
        if (active && !feverMode) {
             if (rectIntersect(player.x+10, player.y+10, player.w-20, player.h-20, e.x+10, e.y+10, e.w-20, e.h-20)) {
                 if (e.type === 'bomb') {
                     loseLife();
                     createParticles(player.x, player.y, 'splash');
                 } else {
                     player.hit();
                 }
                 return false; // Enemy disappears on hit
             }
        }
        return active;
    });

    // Dancers
    dancers = dancers.filter(d => {
        let active = d.update();
        // Hold to collect logic is in checkEatCollision for simplicity, 
        // but let's add proximity pickup or touch pickup here?
        // Requirement says "Long press to acquire".
        return active;
    });

    // Particles
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);

    // Popups
    popups.forEach(p => p.update());
    popups = popups.filter(p => p.life > 0);
}

function checkEatCollision() {
    // Eating Food
    foods = foods.filter(f => {
        if (rectIntersect(player.x, player.y, player.w, player.h, f.x, f.y, f.w, f.h)) {
            stamina = Math.min(maxStamina, stamina + 20);
            createParticles(player.x + player.w/2, player.y, 'heart');
            addPopup(player.x, player.y - 20, "+HP", "#0f0");
            score += 10;
            return false; // Eaten
        }
        return true;
    });

    // Recruiting Dancers
    dancers = dancers.filter(d => {
         if (rectIntersect(player.x, player.y, player.w, player.h, d.x, d.y, d.w, d.h)) {
            player.dancerStack++;
            dancersCollected++;
            addPopup(player.x, player.y - 20, "JOIN!", "#ff69b4");
            createParticles(player.x, player.y, 'sparkle');
            return false;
         }
         return true;
    });
}

function drawEntities() {
    chicks.forEach(c => c.draw());
    foods.forEach(f => f.draw());
    enemies.forEach(e => e.draw());
    dancers.forEach(d => d.draw());
    player.draw();
    particles.forEach(p => p.draw());
    popups.forEach(p => p.draw());
}

function checkFever() {
    if (roostersRaisedCycle >= 3) {
        feverMode = true;
        feverTimer = 600; // 10 seconds at 60fps
        roostersRaisedCycle = 0;
        document.querySelector('body').classList.add('fever-bg');
        showWaveText("üî• FEVER TIME üî•");
        addPopup(SCREEN_W/2, SCREEN_H/2, "FEVER!!", "#ff0000", 50);
        
        // Clear enemies
        enemies = [];
    }
}

function decreaseStamina(amount) {
    if (feverMode) return;
    stamina -= amount;
    if (stamina <= 0) {
        stamina = 0;
        loseLife();
        stamina = 100; // Recover after losing life
    }
}

function loseLife() {
    lives--;
    player.vy = -20; // Big bounce
    player.state = 'hit';
    
    if (lives <= 0) {
        gameOver();
    } else {
        // Temp reset pos
        setTimeout(() => {
            player.y = player.groundY;
            player.state = 'idle';
            player.invincible = 120;
            // Clear screen dangerous items
            enemies = []; 
        }, 1000);
    }
    updateUI();
}

function gameOver() {
    gameState = 'gameover';
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = score;
    document.getElementById('finalRoosters').innerText = roostersTotal;
    document.getElementById('finalDancers').innerText = dancersCollected;
    
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('piyoMeshiHighScore', highScore);
    }
    updateHighScore();
}

function updateUI() {
    document.getElementById('scoreVal').innerText = score;
    document.getElementById('staminaFill').style.width = stamina + "%";
    
    let hearts = "";
    for(let i=0; i<lives; i++) hearts += "‚ù§Ô∏è";
    document.getElementById('lifeContainer').innerText = hearts;
}

function updateHighScore() {
    const el = document.getElementById('highScoreDisplay');
    if (el) el.innerText = highScore;
}

function createParticles(x, y, type) {
    for(let i=0; i<5; i++) {
        particles.push(new Particle(x, y, type));
    }
}

function addPopup(x, y, text, color, size) {
    popups.push(new Popup(x, y, text, color, size));
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

/* =================================================================
   INPUT HANDLING
   =================================================================
*/

function handleTouchStart(e) {
    if (gameState !== 'playing') return;
    // Don't prevent default if hitting buttons, but here we just cover canvas
    if (e.target.tagName !== 'BUTTON') e.preventDefault();
    
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    isTouching = true;
}

function handleTouchMove(e) {
    if (gameState !== 'playing') return;
    e.preventDefault();
    if (!player) return;

    const touch = e.touches[0];
    const diffX = touch.clientX - touchStartX;
    
    // Direct movement mapping + Inertia
    player.vx = diffX * 0.15;
    
    // Update for next frame to make relative
    touchStartX = touch.clientX;
}

function handleTouchEnd(e) {
    if (gameState !== 'playing') return;
    e.preventDefault();
    
    isTouching = false;
    
    // If hold was short, it's a TAP
    if (holdTimer <= HOLD_THRESHOLD) {
        player.jump();
    }
    
    holdTimer = 0;
    isHolding = false;
    if (player.state === 'eat') player.state = 'idle';
}

// Mouse Fallback (For Debugging on Desktop)
function handleMouseDown(e) {
    handleTouchStart({ touches: [{ clientX: e.clientX, clientY: e.clientY }], preventDefault: ()=>{} });
}
function handleMouseMove(e) {
    if(isTouching) handleTouchMove({ touches: [{ clientX: e.clientX, clientY: e.clientY }], preventDefault: ()=>{} });
}
function handleMouseUp(e) {
    handleTouchEnd({ preventDefault: ()=>{} });
}

// Boot
window.onload = init;

</script>
</body>
</html>

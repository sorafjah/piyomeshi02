<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„Éî„É®È£Ø - Piyo-Meshi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap');

        body {
            font-family: 'Mochiy Pop One', sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent browser zooming/scrolling */
            user-select: none;
            -webkit-user-select: none;
            background-color: #87CEEB; /* Sky Blue */
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay Styling */
        .ui-layer {
            position: absolute;
            pointer-events: none; /* Let touches pass through to canvas */
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 16px;
            box-sizing: border-box;
        }

        .stamina-bar-container {
            width: 150px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
        }

        .stamina-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #fcd34d, #f59e0b);
            width: 100%;
            transition: width 0.1s linear;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .pulse-anim { animation: pulse 0.5s infinite; }

        #game-over-screen, #start-screen {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .hidden { display: none !important; }
    </style>
</head>
<body class="h-screen w-screen relative">

    <!-- Game Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- In-Game UI -->
    <div id="ui-layer" class="ui-layer hidden">
        <div class="flex justify-between items-start w-full">
            <!-- Top Left: Lives & Stamina -->
            <div class="flex flex-col gap-2">
                <div class="flex text-3xl drop-shadow-md" id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div class="flex items-center gap-2 glass-panel px-3 py-1">
                    <span class="text-xl">üí™</span>
                    <div class="stamina-bar-container">
                        <div id="stamina-fill" class="stamina-bar-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Top Right: Score -->
            <div class="glass-panel px-4 py-2 flex flex-col items-end">
                <span class="text-xs text-white font-bold tracking-wider">SCORE</span>
                <span id="score-display" class="text-4xl text-white font-bold drop-shadow-lg">0</span>
            </div>
        </div>

        <!-- Fever Indicator -->
        <div id="fever-indicator" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-6xl hidden pulse-anim font-bold text-yellow-300 drop-shadow-[0_0_10px_rgba(255,100,0,0.8)] pointer-events-none text-center whitespace-nowrap">
            FEVER TIME!!<br>üî•üî•üî•
        </div>

        <!-- Controls Hint (Fades out) -->
        <div id="controls-hint" class="absolute bottom-20 left-0 w-full text-center text-white text-opacity-80 text-sm pointer-events-none">
            üëà „Çπ„ÉØ„Ç§„ÉóÁßªÂãï üëâ | „Çø„ÉÉ„Éó„Åß„Ç∏„É£„É≥„Éó üîº | Èï∑Êäº„Åó„ÅßÈ£ü„Åπ„Çã üçΩÔ∏è
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center z-50 text-white">
        <h1 class="text-6xl mb-4 drop-shadow-lg">„Éî„É®È£Ø</h1>
        <p class="text-xl mb-8 text-center opacity-90">„Éí„É®„Ç≥„ÇíËÇ≤„Å¶„Çà„ÅÜÔºÅ<br>üçé„ÇíÊâì„Å°‰∏ä„Åí„Å¶È£ü„Åπ„Åï„Åõ„Å¶„Å≠</p>
        <div class="glass-panel p-6 rounded-2xl text-center max-w-md mx-4 mb-8 text-sm leading-relaxed">
            <div class="grid grid-cols-[auto_1fr] gap-x-4 gap-y-2 text-left items-center">
                <span class="text-2xl">üëÜ</span> <span><b>„Çø„ÉÉ„Éó</b>Ôºö„Ç∏„É£„É≥„ÉóÔºÜÊâì„Å°‰∏ä„Åí</span>
                <span class="text-2xl">‚ÜîÔ∏è</span> <span><b>„Çπ„ÉØ„Ç§„Éó</b>ÔºöÁßªÂãï</span>
                <span class="text-2xl">üçΩÔ∏è</span> <span><b>Èï∑Êäº„Åó</b>ÔºöÈ£ü„Åπ„Å¶ÂõûÂæ©</span>
            </div>
        </div>
        <button id="start-btn" class="bg-yellow-400 hover:bg-yellow-500 text-yellow-900 font-bold py-4 px-12 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95">
            „Çπ„Çø„Éº„ÉàÔºÅ
        </button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center z-50 hidden text-white">
        <h2 class="text-5xl mb-6 text-red-400 font-bold drop-shadow-lg">GAME OVER</h2>
        
        <div class="glass-panel p-8 rounded-2xl w-80 mb-8">
            <div class="flex justify-between mb-4 text-lg border-b border-white/30 pb-2">
                <span>SCORE</span>
                <span id="final-score" class="font-bold text-2xl">0</span>
            </div>
            <div class="flex justify-between mb-2 text-sm">
                <span>üêì ËÇ≤„Å£„ÅüÊï∞</span>
                <span id="final-chicks" class="font-bold">0</span>
            </div>
            <div class="flex justify-between mb-2 text-sm">
                <span>üíÉ ‰ª≤Èñì„ÉÄ„É≥„Çµ„Éº</span>
                <span id="final-dancers" class="font-bold">0</span>
            </div>
            <div class="mt-4 pt-2 border-t border-white/30 text-center text-yellow-300 text-xs">
                HIGHSCORE: <span id="highscore-display">0</span>
            </div>
        </div>

        <button id="restart-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-10 rounded-full text-xl shadow-lg transform transition hover:scale-105 active:scale-95">
            „ÇÇ„ÅÜ‰∏ÄÂ∫¶ÈÅä„Å∂
        </button>
    </div>

    <script>
        /* --- Game Constants & Assets --- */
        const ASSETS = {
            player: 'üï∫',
            food: ['üçé', 'üçî', 'üçá', 'üçô', 'üç©'],
            chick: ['üê£', 'üê•', 'üêì'],
            dog: 'üêï',
            lightning: '‚ö°',
            bomb: 'üí£',
            dancer: 'üíÉ',
            heart: '‚ù§Ô∏è'
        };

        const COLORS = {
            ground: '#8B4513', // SaddleBrown
            grass: '#228B22',  // ForestGreen
            sky: '#87CEEB'
        };

        /* --- Game State & Variables --- */
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const uiLayer = document.getElementById('ui-layer');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreEl = document.getElementById('score-display');
        const livesEl = document.getElementById('lives-display');
        const staminaEl = document.getElementById('stamina-fill');
        const feverEl = document.getElementById('fever-indicator');
        const finalScoreEl = document.getElementById('final-score');
        const finalChicksEl = document.getElementById('final-chicks');
        const finalDancersEl = document.getElementById('final-dancers');
        const highscoreEl = document.getElementById('highscore-display');
        const controlsHint = document.getElementById('controls-hint');

        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let frameId;
        let lastTime = 0;
        let width, height;
        let scaleRatio = 1;

        // Game Data
        let score = 0;
        let highScore = localStorage.getItem('piyoHighscore') || 0;
        let lives = 3;
        let stamina = 100;
        let chicksRaised = 0;
        let dancersCollected = 0;
        
        // Fever Logic
        let feverActive = false;
        let feverTimer = 0;
        let chickensUntilFever = 3;

        // Entities
        let player;
        let foods = [];
        let chicks = [];
        let enemies = [];
        let dancers = [];
        let particles = [];
        let texts = []; // Floating texts

        /* --- Input Handling --- */
        const input = {
            touchStartX: 0,
            touchStartY: 0,
            touchCurrentX: 0,
            isTouching: false,
            touchStartTime: 0,
            isLongPress: false,
            longPressTimer: null,
            swipeThreshold: 10
        };

        /* --- Classes --- */
        
        class Player {
            constructor() {
                this.w = 50 * scaleRatio;
                this.h = 60 * scaleRatio;
                this.x = width / 2 - this.w / 2;
                this.y = height - 100 * scaleRatio - this.h; // On grass
                this.groundY = this.y;
                this.vx = 0;
                this.vy = 0;
                this.isJumping = false;
                this.wobble = 0;
                this.invincible = 0; // frames
            }

            update(dt) {
                // Movement from swipe
                if (input.isTouching && !input.isLongPress) {
                    const diffX = input.touchCurrentX - input.touchStartX;
                    // Smooth follow logic
                    const targetX = this.x + diffX * 0.1; 
                    this.vx = (targetX - this.x) * 0.2;
                    
                    // Update anchor for next frame to prevent sliding
                    if(Math.abs(diffX) > 1) {
                         // Slight drift feel
                    }
                } else {
                    this.vx *= 0.9; // friction
                }

                this.x += this.vx;

                // Bounds
                if (this.x < 0) this.x = 0;
                if (this.x > width - this.w) this.x = width - this.w;

                // Gravity / Jump
                if (this.isJumping) {
                    this.vy += 0.5 * scaleRatio; // gravity
                    this.y += this.vy;
                    if (this.y >= this.groundY) {
                        this.y = this.groundY;
                        this.isJumping = false;
                        this.vy = 0;
                    }
                }

                // Wobble animation
                if (Math.abs(this.vx) > 0.5) {
                    this.wobble += 0.2;
                } else {
                    this.wobble = 0;
                }

                // Invincibility
                if (this.invincible > 0) this.invincible--;

                // Long Press Eating
                if (input.isLongPress && input.isTouching) {
                    // Recover stamina if touching food
                    foods.forEach((f, i) => {
                        if (checkCollision(this, f)) {
                            createParticle(f.x, f.y, '‚ú®');
                            stamina = Math.min(100, stamina + 1); // Fast refill
                            f.eaten = true;
                        }
                    });
                    // Collect Dancers
                    dancers.forEach(d => {
                         if (!d.collected && checkCollision(this, d)) {
                             d.collected = true;
                             dancersCollected++;
                             createFloatingText(this.x, this.y - 50, "GET!", "#ff69b4");
                         }
                    });
                }
            }

            draw(ctx) {
                if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; // Blink

                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                
                // Rotation wobble
                const rot = Math.sin(this.wobble) * 0.1;
                ctx.rotate(rot);

                // Draw Dancer Dummies (Allies)
                dancers.forEach((d, i) => {
                    if (d.collected) {
                        // Draw behind player
                        ctx.font = `${30 * scaleRatio}px sans-serif`;
                        ctx.fillText(ASSETS.dancer, -40 * scaleRatio + (i * 10), 10);
                    }
                });

                ctx.font = `${50 * scaleRatio}px sans-serif`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(ASSETS.player, 0, 0);
                
                // Long press indicator
                if (input.isLongPress) {
                    ctx.beginPath();
                    ctx.arc(0, -40, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fill();
                    ctx.fillText('üçΩÔ∏è', 0, -60);
                }
                
                ctx.restore();
            }

            jump() {
                if (!this.isJumping && stamina >= 5 && !input.isLongPress) {
                    this.vy = -12 * scaleRatio;
                    this.isJumping = true;
                    stamina -= 10;
                    updateUI();
                }
            }

            takeDamage(amount, isLifeLost = false) {
                if (this.invincible > 0 || feverActive) return;
                
                // Check for dancers to sacrifice
                const activeDancers = dancers.filter(d => d.collected);
                if (activeDancers.length > 0) {
                    // Sacrifice a dancer
                    const sacrificed = activeDancers[0];
                    sacrificed.collected = false; // Technically remove from collected logic
                    // Find actual object index to remove completely or visuals
                    const idx = dancers.indexOf(sacrificed);
                    if(idx > -1) dancers.splice(idx, 1);
                    
                    createFloatingText(this.x, this.y, "SHIELD!", "#ff69b4");
                    this.invincible = 60;
                    return;
                }

                if (isLifeLost) {
                    lives--;
                    stamina = 100; // Reset stamina on life lost
                    this.invincible = 120;
                    // Bounce effect
                    this.vy = -10 * scaleRatio;
                    this.isJumping = true;
                    createFloatingText(this.x, this.y, "OUCH!", "red");
                    
                    if (lives <= 0) endGame();
                } else {
                    stamina -= amount;
                    if (stamina <= 0) {
                        stamina = 0;
                        this.takeDamage(0, true); // Lose life if stamina 0
                    } else {
                        this.invincible = 30;
                    }
                }
                updateUI();
            }
        }

        class Food {
            constructor() {
                this.type = ASSETS.food[Math.floor(Math.random() * ASSETS.food.length)];
                this.w = 30 * scaleRatio;
                this.h = 30 * scaleRatio;
                this.x = Math.random() * (width - this.w);
                this.y = -50;
                this.vy = (Math.random() * 1 + 1) * scaleRatio; // Slow fall
                this.eaten = false;
                this.isRising = false;
            }

            update() {
                this.y += this.vy;

                // Gravity logic
                if (this.isRising) {
                    this.vy += 0.3 * scaleRatio; // Gravity pulls it back down
                }

                // Hit floor
                if (this.y > height - 80 * scaleRatio) {
                    this.eaten = true; // Remove
                    if (!feverActive) {
                        player.takeDamage(15); // Damage for dropping food
                        createFloatingText(this.x, height - 80, "DROP!", "orange");
                    }
                }

                // Hit Player
                if (!this.isRising && checkCollision(this, player)) {
                    if (player.isJumping && player.vy < 0) {
                        // Hit up!
                        this.vy = -15 * scaleRatio; // Shoot up
                        this.isRising = true;
                        createParticle(this.x, this.y, 'üí®');
                    }
                }
            }

            draw(ctx) {
                ctx.font = `${30 * scaleRatio}px sans-serif`;
                ctx.fillText(this.type, this.x, this.y + this.h);
            }
        }

        class Chick {
            constructor(index) {
                this.index = index; // 0 or 1
                this.stage = 0; // 0:üê£, 1:üê•, 2:üêì
                this.w = 40 * scaleRatio;
                this.h = 40 * scaleRatio;
                // Position at top, distinct zones
                this.zoneW = width / 2;
                this.x = (this.index * this.zoneW) + (this.zoneW / 2);
                this.y = 60 * scaleRatio;
                this.baseY = this.y;
                this.vx = 1 * scaleRatio;
                this.offset = Math.random() * 100;
                this.leaving = false;
            }

            update() {
                if (this.leaving) {
                    this.y -= 5 * scaleRatio;
                    this.x += Math.sin(this.offset) * 5;
                    return; // Don't eat
                }

                // Hover motion
                this.offset += 0.05;
                this.y = this.baseY + Math.sin(this.offset) * 10;
                this.x += Math.cos(this.offset * 0.5) * 1; // Slight drift

                // Eat rising food
                foods.forEach(f => {
                    if (f.isRising && !f.eaten && checkCollision(this, f)) {
                        f.eaten = true;
                        this.grow();
                        score += 100;
                        createFloatingText(this.x, this.y, "YUM!", "#FFFF00");
                        createParticle(this.x, this.y, '‚ù§Ô∏è');
                        updateUI();
                    }
                });
            }

            grow() {
                this.stage++;
                if (this.stage >= 3) {
                    // Fully grown
                    createFloatingText(this.x, this.y, "+1000", "gold");
                    score += 1000;
                    chicksRaised++;
                    this.leaving = true;
                    
                    // Fever check
                    chickensUntilFever--;
                    if (chickensUntilFever <= 0) {
                        startFever();
                    }

                    // Respawn logic handled in main loop removal
                }
            }

            draw(ctx) {
                ctx.font = `${40 * scaleRatio}px sans-serif`;
                let char = ASSETS.chick[Math.min(this.stage, 2)];
                ctx.fillText(char, this.x, this.y + this.h);
            }
        }

        class Enemy {
            constructor(type) {
                this.type = type; // 'dog', 'lightning', 'bomb'
                this.w = 40 * scaleRatio;
                this.h = 40 * scaleRatio;
                
                if (type === 'dog') {
                    this.y = height - 100 * scaleRatio - 30;
                    this.vx = (Math.random() < 0.5 ? 1 : -1) * (2 + Math.random() * 2) * scaleRatio;
                    this.x = this.vx > 0 ? -50 : width + 50;
                } else {
                    // Lightning/Bomb
                    this.x = Math.random() * (width - 50);
                    this.y = -50;
                    this.vy = (type === 'lightning' ? 6 : 3) * scaleRatio;
                }
                this.active = true;
            }

            update() {
                if (this.type === 'dog') {
                    this.x += this.vx;
                    this.y = height - 100 * scaleRatio - 20 + Math.sin(Date.now()/100)*5; // Bounce
                    if (this.x > width + 100 || this.x < -100) this.active = false;
                } else {
                    this.y += this.vy;
                    if (this.y > height) this.active = false;
                }

                if (this.active && checkCollision(this, player)) {
                    if (this.type === 'bomb') {
                        player.takeDamage(0, true); // Lose life
                    } else {
                        player.takeDamage(30);
                    }
                    this.active = false; // Remove enemy after hit
                    createParticle(player.x, player.y, 'üí•');
                }
            }

            draw(ctx) {
                let char = '';
                if (this.type === 'dog') char = ASSETS.dog;
                if (this.type === 'lightning') char = ASSETS.lightning;
                if (this.type === 'bomb') char = ASSETS.bomb;

                ctx.font = `${35 * scaleRatio}px sans-serif`;
                
                if (this.type === 'dog' && this.vx > 0) {
                    // Flip dog if running right
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.scale(-1, 1);
                    ctx.fillText(char, -this.w, this.h);
                    ctx.restore();
                } else {
                    ctx.fillText(char, this.x, this.y + this.h);
                }
            }
        }

        class Dancer {
            constructor() {
                this.w = 30 * scaleRatio;
                this.h = 40 * scaleRatio;
                this.x = Math.random() * (width - 40);
                this.y = -50;
                this.vy = 2 * scaleRatio;
                this.rot = 0;
                this.collected = false;
                this.active = true;
            }

            update() {
                if (this.collected) {
                    // Follow player
                    let targetX = player.x + (dancers.indexOf(this) + 1) * 10;
                    let targetY = player.y - 10;
                    this.x += (targetX - this.x) * 0.1;
                    this.y += (targetY - this.y) * 0.1;
                    return;
                }

                this.y += this.vy;
                this.rot += 0.1;

                if (this.y > height) this.active = false;
            }

            draw(ctx) {
                if (this.collected) return; // Player draws collected ones

                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.rotate(this.rot);
                ctx.font = `${30 * scaleRatio}px sans-serif`;
                ctx.fillText(ASSETS.dancer, -this.w/2, this.h/2 - 10);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, char) {
                this.x = x;
                this.y = y;
                this.char = char;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.font = "20px sans-serif";
                ctx.fillText(this.char, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1.0;
                this.vy = -2;
            }
            update() {
                this.y += this.vy;
                this.life -= 0.02;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.font = `bold ${24 * scaleRatio}px sans-serif`;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4;
                ctx.fillText(this.text, this.x, this.y);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        /* --- Functions --- */

        function init() {
            resize();
            window.addEventListener('resize', resize);
            setupInput();

            // Start Screen
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', startGame);
            
            // Initial Render
            renderBackground();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            scaleRatio = Math.min(width / 400, 1.5); // Base design on ~400px width
            if(player) {
                 player.groundY = height - 100 * scaleRatio - player.h;
                 if (!player.isJumping) player.y = player.groundY;
            }
        }

        function startGame() {
            gameState = 'PLAYING';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            uiLayer.classList.remove('hidden');

            // Reset Data
            score = 0;
            lives = 3;
            stamina = 100;
            chicksRaised = 0;
            dancersCollected = 0;
            feverActive = false;
            chickensUntilFever = 3;
            
            player = new Player();
            foods = [];
            enemies = [];
            dancers = [];
            particles = [];
            texts = [];
            chicks = [new Chick(0), new Chick(1)];

            lastTime = performance.now();
            loop(lastTime);
            
            // Fade out hints
            setTimeout(() => {
                controlsHint.style.opacity = '0';
                controlsHint.style.transition = 'opacity 2s';
            }, 3000);
        }

        function endGame() {
            gameState = 'GAME_OVER';
            uiLayer.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            finalScoreEl.innerText = score;
            finalChicksEl.innerText = chicksRaised;
            finalDancersEl.innerText = dancersCollected;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('piyoHighscore', highScore);
            }
            highscoreEl.innerText = highScore;
        }

        function startFever() {
            feverActive = true;
            feverTimer = 10; // 10 seconds
            feverEl.classList.remove('hidden');
            // Replenish chicks
            chicks = [new Chick(0), new Chick(1)];
        }

        function spawnEntities() {
            // Food
            let maxFood = feverActive ? 5 : 2;
            if (foods.length < maxFood && Math.random() < 0.02) {
                foods.push(new Food());
            }

            // Chicks Respawn
            chicks = chicks.filter(c => !c.leaving || c.y > -50); // Keep if not left fully
            if (chicks.filter(c => !c.leaving).length < 2 && Math.random() < 0.01) {
                // Find empty slot
                let slot0 = chicks.some(c => !c.leaving && c.index === 0);
                if (!slot0) chicks.push(new Chick(0));
                else chicks.push(new Chick(1));
            }

            // Enemies
            if (!feverActive && Math.random() < 0.005) {
                const r = Math.random();
                if (r < 0.4) enemies.push(new Enemy('dog'));
                else if (r < 0.8) enemies.push(new Enemy('lightning'));
                else enemies.push(new Enemy('bomb'));
            }

            // Dancers
            if (Math.random() < 0.002) {
                dancers.push(new Dancer());
            }
        }

        function checkCollision(rect1, rect2) {
            return (rect1.x < rect2.x + rect2.w &&
                    rect1.x + rect1.w > rect2.x &&
                    rect1.y < rect2.y + rect2.h &&
                    rect1.y + rect1.h > rect2.y);
        }

        function updateUI() {
            scoreEl.innerText = score;
            livesEl.innerText = '‚ù§Ô∏è'.repeat(lives);
            staminaEl.style.width = `${stamina}%`;
        }

        function loop(timestamp) {
            if (gameState !== 'PLAYING') return;
            frameId = requestAnimationFrame(loop);

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, width, height);
            
            renderBackground();

            // Logic
            spawnEntities();
            player.update(dt);

            // Fever Timer
            if (feverActive) {
                feverTimer -= dt / 1000;
                if (feverTimer <= 0) {
                    feverActive = false;
                    feverEl.classList.add('hidden');
                    chickensUntilFever = 3;
                }
            }

            // Entity Updates & Removal
            foods.forEach(e => e.update());
            foods = foods.filter(e => !e.eaten);

            chicks.forEach(e => e.update());
            // Chicks removal handled in spawn logic primarily, but cleanup offscreen
            chicks = chicks.filter(c => c.y > -100);

            enemies.forEach(e => e.update());
            enemies = enemies.filter(e => e.active);

            dancers.forEach(e => e.update());
            dancers = dancers.filter(e => e.active); // Keep collected ones in logic array

            particles.forEach(e => e.update());
            particles = particles.filter(e => e.life > 0);

            texts.forEach(e => e.update());
            texts = texts.filter(e => e.life > 0);

            // Drawing
            chicks.forEach(e => e.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            dancers.forEach(e => e.draw(ctx));
            player.draw(ctx); // Player draws collected dancers behind self
            foods.forEach(e => e.draw(ctx));
            particles.forEach(e => e.draw(ctx));
            texts.forEach(e => e.draw(ctx));
        }

        function renderBackground() {
            // Sky
            ctx.fillStyle = COLORS.sky;
            ctx.fillRect(0, 0, width, height);
            
            // Grass
            ctx.fillStyle = COLORS.grass;
            const grassH = 100 * scaleRatio;
            ctx.fillRect(0, height - grassH, width, 20 * scaleRatio);
            
            // Soil
            ctx.fillStyle = COLORS.ground;
            ctx.fillRect(0, height - grassH + 20 * scaleRatio, width, grassH);
        }

        function createParticle(x, y, char) {
            for(let i=0; i<5; i++) {
                particles.push(new Particle(x, y, char));
            }
        }

        function createFloatingText(x, y, text, color) {
            texts.push(new FloatingText(x, y, text, color));
        }

        /* --- Event Listeners --- */
        function setupInput() {
            // Touch
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.touches[0];
                input.touchStartX = t.clientX;
                input.touchStartY = t.clientY;
                input.touchCurrentX = t.clientX;
                input.isTouching = true;
                input.touchStartTime = Date.now();
                input.isLongPress = false;

                // Start Long Press Timer
                input.longPressTimer = setTimeout(() => {
                    if (input.isTouching && Math.abs(input.touchCurrentX - input.touchStartX) < input.swipeThreshold) {
                        input.isLongPress = true;
                    }
                }, 300); // 300ms for long press
            }, {passive: false});

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (!input.isTouching) return;
                const t = e.touches[0];
                input.touchCurrentX = t.clientX;

                // Cancel long press if moved too much
                if (Math.abs(input.touchCurrentX - input.touchStartX) > input.swipeThreshold) {
                    clearTimeout(input.longPressTimer);
                    input.isLongPress = false;
                }
            }, {passive: false});

            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                const duration = Date.now() - input.touchStartTime;
                const dist = Math.abs(input.touchCurrentX - input.touchStartX);

                clearTimeout(input.longPressTimer);

                if (!input.isLongPress && dist < input.swipeThreshold && duration < 300) {
                    // Tap detected -> Jump
                    if (gameState === 'PLAYING') player.jump();
                }

                input.isTouching = false;
                input.isLongPress = false;
            }, {passive: false});

            // Mouse Support for PC testing
            canvas.addEventListener('mousedown', e => {
                input.touchStartX = e.clientX;
                input.touchCurrentX = e.clientX;
                input.isTouching = true;
                input.touchStartTime = Date.now();
                input.isLongPress = false;
                input.longPressTimer = setTimeout(() => {
                     if (input.isTouching && Math.abs(input.touchCurrentX - input.touchStartX) < input.swipeThreshold) {
                        input.isLongPress = true;
                    }
                }, 300);
            });
            canvas.addEventListener('mousemove', e => {
                if (!input.isTouching) return;
                input.touchCurrentX = e.clientX;
                if (Math.abs(input.touchCurrentX - input.touchStartX) > input.swipeThreshold) {
                    clearTimeout(input.longPressTimer);
                    input.isLongPress = false;
                }
            });
            canvas.addEventListener('mouseup', e => {
                const duration = Date.now() - input.touchStartTime;
                const dist = Math.abs(input.touchCurrentX - input.touchStartX);
                clearTimeout(input.longPressTimer);
                if (!input.isLongPress && dist < input.swipeThreshold && duration < 300) {
                     if (gameState === 'PLAYING') player.jump();
                }
                input.isTouching = false;
                input.isLongPress = false;
            });
        }

        // Init
        init();

    </script>
</body>
</html>
